# -*- coding: utf-8 -*-
"""
Created on Wed Aug 20 18:54:49 2025

@author: camic

Este c√≥digo desarrolla una simulaci√≥n simple de un robot en una grilla 2x2,
aplicando los conceptos de:
- Estado
- Espacio de estados
- Acciones
- Recompensa
- Ambiente

Adem√°s, cumple con los 4 puntos solicitados en la tarea:

1. Modificar la funci√≥n mover_robot para que la bater√≠a baje en cada movimiento.
2. Si la bater√≠a llega a 0, el robot no se puede mover hasta recargar.
3. A√±adir m√°s recompensas o castigos (intentar moverse sin bater√≠a, bonus por llegar r√°pido, etc).
4. Probar diferentes estrategias de movimiento para maximizar la recompensa.
"""

# ========================
# 1. VARIABLES DE ESTADO
# ========================
# Estado inicial del robot
estado_robot = {
    "posicion": (0, 0),
    "bateria": 50,
    "objetivo_alcanzado": False
}

print("Estado inicial del robot:", estado_robot)

# ========================
# 2. ESPACIO DE ESTADOS
# ========================
posiciones = [(x, y) for x in range(3) for y in range(3)]
baterias = ["alta", "baja"]

espacio_estados = [(p, b) for p in posiciones for b in baterias]
print("\nTotal de estados posibles:", len(espacio_estados))
print("Ejemplos de estados:", espacio_estados[:5])

# ========================
# 3. ESPACIO DE ACCIONES
# ========================
acciones = ["adelante", "atras", "izquierda", "derecha", "recargar"]
print("\nAcciones posibles:", acciones)

# ========================
# 4. FUNCI√ìN DE RECOMPENSA
# ========================
# üîπ NUEVO: se agreg√≥ esta funci√≥n para manejar las recompensas y castigos.
# Antes solo exist√≠a el movimiento, ahora se cuantifican las acciones.
def recompensa(accion, nuevo_estado, paso):
    # Recompensa por recargar
    if accion == "recargar":
        return 5
    
    # Castigo por intentar moverse sin bater√≠a (PUNTO 3)
    if accion in ["adelante", "atras", "izquierda", "derecha"] and nuevo_estado["bateria"] == 0 and not nuevo_estado["objetivo_alcanzado"]:
        return -5  

    # Recompensa por alcanzar el objetivo
    if nuevo_estado["objetivo_alcanzado"]:
        if paso < 5:  # Bonus por hacerlo r√°pido (PUNTO 3)
            return 30  
        else:
            return 10  
    
    # Costo de cada movimiento normal
    if accion in ["adelante", "atras", "izquierda", "derecha"]:
        return -1  
    
    return 0

# ========================
# 5. AMBIENTE Y SIMULACI√ìN
# ========================
# üîπ FUNCION MODIFICADA: mover_robot ahora incluye el consumo de bater√≠a y bloqueo
# si la bater√≠a llega a 0 (PUNTOS 1 y 2).
def mover_robot(estado, accion):
    x, y = estado["posicion"]

    if accion in ["adelante", "atras", "derecha", "izquierda"]:
        # SOLO se mueve si tiene bater√≠a
        if estado["bateria"] > 0:
            if accion == "adelante":
                x = min(x + 1, 2)
            elif accion == "atras":
                x = max(x - 1, 0)
            elif accion == "derecha":
                y = min(y + 1, 2)
            elif accion == "izquierda":
                y = max(y - 1, 0)
            
            # üîπ CAMBIO: la bater√≠a baja en cada movimiento (PUNTO 1)
            estado["bateria"] = max(estado["bateria"] - 10, 0)
        else:
            # üîπ CAMBIO: aviso si no puede moverse por falta de bater√≠a (PUNTO 2)
            print("‚ö†Ô∏è BATERIA AGOTADA, POR FAVOR RECARGA")

    elif accion == "recargar":
        # üîπ NUEVO: acci√≥n de recarga (PUNTO 2)
        estado["bateria"] = 100

    # Se actualiza la posici√≥n
    estado["posicion"] = (x, y)

    # üîπ CAMBIO: Se define (2,2) como el objetivo final
    if estado["posicion"] == (2, 2):
        estado["objetivo_alcanzado"] = True

    return estado

# ========================
# 6. SIMULACI√ìN DEL ROBOT (MANUAL)
# ========================
# üîπ NUEVO: se agreg√≥ un bucle para controlar el robot manualmente (PUNTO 4).
estado = {"posicion": (0, 0), "bateria": 50, "objetivo_alcanzado": False}
recompensa_total = 0

print("\n=== SIMULACI√ìN DEL ROBOT (MODO MANUAL) ===")
for paso in range(10):  # Se limita a 10 pasos
    print("\nEstado actual:", estado)
    accion = input("Elige una acci√≥n (adelante, atras, izquierda, derecha, recargar): ")

    # Normalizamos la entrada
    accion = accion.strip().lower()

    if accion not in acciones:
        print("‚ö†Ô∏è Acci√≥n no v√°lida, intenta de nuevo.")
        continue

    # Se actualiza el estado con la acci√≥n elegida
    estado = mover_robot(estado, accion)

    # Se calcula la recompensa correspondiente
    r = recompensa(accion, estado, paso)
    recompensa_total += r

    print(f"Paso {paso+1}: Acci√≥n = {accion}, Estado = {estado}, Recompensa = {r}")

    # Si el robot llega a la meta, se termina la simulaci√≥n
    if estado["objetivo_alcanzado"]:
        print("üéâ ¬°Objetivo alcanzado!")
        break

# Resultado final
print("\n‚úÖ Recompensa total obtenida:", recompensa_total)
